<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gender and Age Detection</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000;
            font-family: Arial, sans-serif;
        }
        
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            color: #fff;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 0.5s ease;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #333;
            border-top: 5px solid #fff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        #container {
            position: relative;
            width: 100%;
            height: 100%;
        }

        video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* Mirror the video */
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        #status {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            z-index: 100;
            text-shadow: 1px 1px 2px black;
        }

        .grayscale {
            filter: grayscale(100%);
        }

        #sidebar {
            position: absolute;
            top: 0;
            right: 0;
            width: 350px;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            border-left: 1px solid rgba(255, 255, 255, 0.2);
            overflow-y: auto;
            z-index: 90;
            padding: 20px;
            box-sizing: border-box;
            color: white;
            font-family: 'Roboto', sans-serif;
        }

        #sidebar h2 {
            margin-top: 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 10px;
            font-size: 18px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .person-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            padding: 10px;
            margin-bottom: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .person-card h3 {
            margin: 0 0 5px 0;
            font-size: 16px;
            color: #2ecc71;
        }

        .person-card p {
            margin: 2px 0;
            font-size: 12px;
            color: #ccc;
        }

        .person-card .meta {
            display: flex;
            justify-content: space-between;
            margin-top: 5px;
            font-size: 10px;
            color: #888;
        }

        #top-controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
        }

        #bottom-controls {
            position: absolute;
            top: 20px;
            right: 370px; /* Adjusted for sidebar */
            z-index: 100;
        }

        button {
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.5);
            color: white;
            cursor: pointer;
            font-size: 16px;
            border-radius: 5px;
            backdrop-filter: blur(5px);
            transition: all 0.3s ease;
        }

        button:hover {
            background: rgba(255, 255, 255, 0.4);
        }

        select {
            padding: 10px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.5);
            color: white;
            font-size: 16px;
            border-radius: 5px;
            margin-right: 10px;
            cursor: pointer;
        }

        label {
            color: white;
            margin-left: 10px;
            font-family: Arial;
            font-size: 14px;
            cursor: pointer;
            background: rgba(0,0,0,0.5);
            padding: 5px;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div id="loading">
        <div class="spinner"></div>
        <h2>Initializing Camera...</h2>
        <p>Please allow camera access</p>
    </div>

    <div id="container">
        <video id="video" autoplay playsinline></video>
        <canvas id="overlay"></canvas>
        <div id="status">Initializing...</div>
        
        <!-- Top Controls -->
        <div id="top-controls" class="ui-element">
            <select id="cameraSelect"></select>
            <button id="bwBtn">B&W Filter</button>
            <button onclick="window.location.href='/dashboard.html'" style="margin-left: 10px;">View Database</button>
            <button id="hideUiBtn">Hide UI</button>
        </div>

        <!-- Bottom Controls -->
        <div id="bottom-controls" class="ui-element">
            <button id="toggle-cam">Stop Camera</button>
            <button id="toggle-detection">Stop Detection</button>
            <button id="toggle-deepface">Enable DeepFace</button>
        </div>

        <div id="sidebar" class="ui-element">
            <h2>Live Feed</h2>
            <div id="people-list">
                <!-- People cards will be added here -->
            </div>
        </div>
        
        <!-- Floating Show UI Button (Hidden by default) -->
        <button id="showUiBtn" style="display: none; position: absolute; top: 20px; right: 20px; z-index: 200;">Show UI</button>
    </div>

    <!-- Hidden canvas for capturing frames -->
    <canvas id="captureCanvas" width="640" height="480" style="display:none;"></canvas>

    <script>
        const video = document.getElementById('video');
        const overlay = document.getElementById('overlay');
        const captureCanvas = document.getElementById('captureCanvas');
        const loadingScreen = document.getElementById('loading');
        const statusDiv = document.getElementById('status');
        
        // UI Elements
        const topControls = document.getElementById('top-controls');
        const bottomControls = document.getElementById('bottom-controls');
        const sidebar = document.getElementById('sidebar');
        const showUiBtn = document.getElementById('showUiBtn');
        const hideUiBtn = document.getElementById('hideUiBtn');
        const peopleList = document.getElementById('people-list');
        
        // Buttons
        const bwBtn = document.getElementById('bwBtn');
        const cameraSelect = document.getElementById('cameraSelect');
        const toggleCamBtn = document.getElementById('toggle-cam');
        const toggleDetectionBtn = document.getElementById('toggle-detection');
        const toggleDeepFaceBtn = document.getElementById('toggle-deepface');

        const ctx = overlay.getContext('2d');
        const captureCtx = captureCanvas.getContext('2d');

        // State
        let isRunning = false;
        let isDetectionRunning = true;
        let isDeepFaceEnabled = false;
        let isBW = false;
        let currentStream = null;
        let lastFrameTime = 0;
        const frameInterval = 100; // 10 FPS
        const detectedPeople = new Map();

        // --- UI Logic ---

        // Hide/Show UI
        function toggleUI(show) {
            const display = show ? 'block' : 'none';
            topControls.style.display = display;
            bottomControls.style.display = display;
            sidebar.style.display = display;
            statusDiv.style.display = display;
            showUiBtn.style.display = show ? 'none' : 'block';
        }

        hideUiBtn.addEventListener('click', () => toggleUI(false));
        showUiBtn.addEventListener('click', () => toggleUI(true));

        // B&W Filter
        bwBtn.addEventListener('click', () => {
            isBW = !isBW;
            if (isBW) {
                video.classList.add('grayscale');
                bwBtn.style.background = 'rgba(0, 255, 255, 0.5)';
                bwBtn.textContent = 'Color Mode';
            } else {
                video.classList.remove('grayscale');
                bwBtn.style.background = 'rgba(255, 255, 255, 0.2)';
                bwBtn.textContent = 'B&W Filter';
            }
        });

        // DeepFace Toggle
        toggleDeepFaceBtn.addEventListener('click', () => {
            isDeepFaceEnabled = !isDeepFaceEnabled;
            if (isDeepFaceEnabled) {
                toggleDeepFaceBtn.style.background = 'rgba(0, 255, 0, 0.5)';
                toggleDeepFaceBtn.textContent = 'Disable DeepFace';
            } else {
                toggleDeepFaceBtn.style.background = 'rgba(255, 255, 255, 0.2)';
                toggleDeepFaceBtn.textContent = 'Enable DeepFace';
            }
        });

        // Detection Toggle
        toggleDetectionBtn.addEventListener('click', () => {
            isDetectionRunning = !isDetectionRunning;
            toggleDetectionBtn.textContent = isDetectionRunning ? 'Stop Detection' : 'Start Detection';
            toggleDetectionBtn.style.background = isDetectionRunning ? 'rgba(255, 255, 255, 0.2)' : 'rgba(255, 0, 0, 0.5)';
            if (isDetectionRunning) detectFrame();
        });

        // Camera Toggle
        toggleCamBtn.addEventListener('click', () => {
            if (currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
                currentStream = null;
                video.srcObject = null;
                toggleCamBtn.textContent = 'Start Camera';
                toggleCamBtn.style.background = 'rgba(255, 0, 0, 0.5)';
                isRunning = false;
            } else {
                startCamera(cameraSelect.value);
                toggleCamBtn.textContent = 'Stop Camera';
                toggleCamBtn.style.background = 'rgba(255, 255, 255, 0.2)';
            }
        });

        // --- Camera Logic ---

        async function getCameras() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoDevices = devices.filter(device => device.kind === 'videoinput');
                
                cameraSelect.innerHTML = '';
                videoDevices.forEach(device => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.text = device.label || `Camera ${cameraSelect.length + 1}`;
                    cameraSelect.appendChild(option);
                });

                if (videoDevices.length === 0) {
                    const option = document.createElement('option');
                    option.text = "No cameras found";
                    cameraSelect.appendChild(option);
                }
            } catch (err) {
                console.error("Error listing cameras:", err);
            }
        }

        cameraSelect.addEventListener('change', () => {
            startCamera(cameraSelect.value);
        });

        async function startCamera(deviceId = null) {
            if (currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
            }

            const constraints = {
                video: {
                    width: { ideal: 1280 },
                    height: { ideal: 720 }
                }
            };

            if (deviceId) {
                constraints.video.deviceId = { exact: deviceId };
            } else {
                constraints.video.facingMode = 'user';
            }

            try {
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                currentStream = stream;
                video.srcObject = stream;
                
                video.onloadedmetadata = () => {
                    loadingScreen.style.opacity = '0';
                    setTimeout(() => {
                        loadingScreen.style.display = 'none';
                        isRunning = true;
                        detectFrame();
                    }, 500);
                };

                if (!deviceId) getCameras();
            } catch (err) {
                console.error('Error accessing camera:', err);
                loadingScreen.innerHTML = `
                    <h2 style="color: #ff4444">Camera Error</h2>
                    <p>${err.message}</p>
                `;
            }
        }

        // --- Detection Logic ---

        function getBackendUrl() {
            const port = 8000;
            const hostname = window.location.hostname;
            const protocol = window.location.protocol;
            
            if (hostname === 'localhost' || hostname === '127.0.0.1') {
                return `${protocol}//${hostname}:${port}/detect`;
            }
            if (hostname.includes('-3000')) {
                const newHostname = hostname.replace('-3000', `-${port}`);
                return `${protocol}//${newHostname}/detect`;
            }
            return `http://localhost:${port}/detect`;
        }

        const API_URL = getBackendUrl();

        async function detectFrame() {
            if (!isRunning || !isDetectionRunning) return;

            const now = Date.now();
            if (now - lastFrameTime < frameInterval) {
                requestAnimationFrame(detectFrame);
                return;
            }
            lastFrameTime = now;

            if (video.readyState === video.HAVE_ENOUGH_DATA) {
                // Draw video to capture canvas (smaller for speed)
                captureCtx.drawImage(video, 0, 0, captureCanvas.width, captureCanvas.height);
                
                captureCanvas.toBlob(async (blob) => {
                    if (!blob) return;

                    const formData = new FormData();
                    formData.append('file', blob, 'frame.jpg');

                    try {
                        const response = await fetch(`${API_URL}?enable_deepface=${isDeepFaceEnabled}`, {
                            method: 'POST',
                            body: formData
                        });

                        if (response.ok) {
                            const data = await response.json();
                            drawResults(data);
                            updateSidebar(data.results);
                            statusDiv.textContent = `Running... Found ${data.results.length} faces.`;
                        }
                    } catch (err) {
                        console.error("Network error", err);
                    }
                    
                    requestAnimationFrame(detectFrame);
                }, 'image/jpeg', 0.7);
            } else {
                requestAnimationFrame(detectFrame);
            }
        }

        function drawResults(data) {
            // Clear overlay
            ctx.clearRect(0, 0, overlay.width, overlay.height);
            
            // Calculate scaling
            // Video is object-fit: cover, so we need to calculate displayed dimensions
            const videoRatio = video.videoWidth / video.videoHeight;
            const screenRatio = overlay.width / overlay.height;
            
            let renderWidth, renderHeight, startX, startY;
            
            if (screenRatio > videoRatio) {
                renderWidth = overlay.width;
                renderHeight = overlay.width / videoRatio;
                startX = 0;
                startY = (overlay.height - renderHeight) / 2;
            } else {
                renderHeight = overlay.height;
                renderWidth = overlay.height * videoRatio;
                startX = (overlay.width - renderWidth) / 2;
                startY = 0;
            }

            const scaleX = renderWidth / captureCanvas.width;
            const scaleY = renderHeight / captureCanvas.height;

            // Draw Objects
            if (data.objects) {
                data.objects.forEach(obj => {
                    let x = obj.box[0] * scaleX + startX;
                    let y = obj.box[1] * scaleY + startY;
                    let w = (obj.box[2] - obj.box[0]) * scaleX;
                    let h = (obj.box[3] - obj.box[1]) * scaleY;

                    // Mirror X
                    const relativeX = x - startX;
                    const mirroredRelativeX = renderWidth - relativeX - w;
                    x = startX + mirroredRelativeX;

                    ctx.strokeStyle = '#FFFF00';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x, y, w, h);
                    
                    ctx.fillStyle = '#FFFF00';
                    ctx.font = '16px Arial';
                    ctx.fillText(`${obj.class}`, x, y - 5);
                });
            }

            // Draw Faces
            if (data.results) {
                data.results.forEach(person => {
                    let x = person.face_box[0] * scaleX + startX;
                    let y = person.face_box[1] * scaleY + startY;
                    let w = (person.face_box[2] - person.face_box[0]) * scaleX;
                    let h = (person.face_box[3] - person.face_box[1]) * scaleY;

                    // Mirror X
                    const relativeX = x - startX;
                    const mirroredRelativeX = renderWidth - relativeX - w;
                    x = startX + mirroredRelativeX;

                    const isNew = person.is_new;
                    const color = isNew ? '#00FFFF' : '#00FF00';

                    // Box
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 3;
                    ctx.strokeRect(x, y, w, h);

                    // Info Box
                    const info = [
                        person.person_id,
                        `Scans: ${person.visits}`,
                        person.gender,
                        person.emotion !== 'Unknown' ? person.emotion : ''
                    ].filter(Boolean);

                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(x, y - (info.length * 20 + 10), 200, info.length * 20 + 10);

                    ctx.fillStyle = color;
                    ctx.font = 'bold 16px Arial';
                    info.forEach((line, i) => {
                        ctx.fillText(line, x + 5, y - ((info.length - 1 - i) * 20) - 10);
                    });
                });
            }
        }

        function updateSidebar(results) {
            detectedPeople.forEach(p => p.seen = false);

            results.forEach(person => {
                const id = person.person_id;
                const now = new Date().toLocaleTimeString();
                
                if (detectedPeople.has(id)) {
                    const p = detectedPeople.get(id);
                    p.seen = true;
                    p.lastSeen = now;
                    
                    const card = document.getElementById(`card-${id}`);
                    if (card) {
                        card.querySelector('.visits').textContent = `Scans: ${person.visits}`;
                        card.querySelector('.emotion').textContent = `Emotion: ${person.emotion}`;
                    }
                } else {
                    detectedPeople.set(id, { seen: true });
                    
                    const card = document.createElement('div');
                    card.className = 'person-card';
                    card.id = `card-${id}`;
                    card.innerHTML = `
                        <h3>${id} <span style="font-size: 12px; color: #888;">(${person.gender})</span></h3>
                        <p class="emotion">Emotion: ${person.emotion}</p>
                        <p class="visits">Scans: ${person.visits}</p>
                        <div class="meta">
                            <span>First: ${now}</span>
                            <span>Last: ${now}</span>
                        </div>
                    `;
                    peopleList.prepend(card);
                }
            });

            // Dim unseen
            detectedPeople.forEach((p, id) => {
                const card = document.getElementById(`card-${id}`);
                if (card) {
                    card.style.opacity = p.seen ? '1' : '0.5';
                }
            });
        }

        // Resize handling
        function resizeCanvas() {
            overlay.width = window.innerWidth;
            overlay.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Start
        startCamera();
    </script>
</body>
</html>